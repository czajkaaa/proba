---
title: "Analiza danych - raport końcowy"
author: "L.Czajkowska, J.Buńkowski, P.Jędrzejewski"
date: "2026-01-19"
output:
  rmdformats::readthedown:
    highlight: kate
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, warning = FALSE, message = FALSE)
```

## 1. Wprowadzenie

### 1.1 Mieszkania

Rynek nieruchomości to jeden z kluczowych sektorów gospodarki, w którym precyzyjna analiza danych ma bezpośrednie przełożenie na trafność decyzji inwestycyjnych. Ten zestaw danych zapewni Ci doskonały przedsmak pracy analityka rynku mieszkaniowego. Pozwoli zrozumieć, z jakimi wyzwaniami mierzą się rzeczoznawcy i inwestorzy, oraz zbadać, jakie strategie wyceny są najskuteczniejsze.

Dzięki zgromadzonym informacjom dowiesz się, jak na atrakcyjność oferty wpływają zróżnicowane zmienne – od parametrów technicznych (rok budowy, piętro), przez lokalizację geograficzną, aż po dostęp do infrastruktury miejskiej (odległość od centrum, szkół czy przychodni).

Jest to w głównej mierze problem **regresji** (przewidywanie ceny) oraz zaawansowanej **eksploracji danych**. Zbiór składa się z **8845 obserwacji** (wierszy) opisanych za pomocą **27 zmiennych** (kolumn).

### 1.2 Opis bazy danych

Baza składa się z **27 kolumn** (cech) opisujących **8845 ofert** mieszkań. Poniżej znajduje się szczegółowy opis każdej zmiennej:

1.  **city** - miasto, w którym zlokalizowana jest nieruchomość (np. Szczecin).
2.  **type** - rodzaj budynku (np. blok mieszkalny, apartamentowiec, kamienica).
3.  **squareMeters** - powierzchnia całkowita mieszkania wyrażona w metrach kwadratowych.
4.  **rooms** - liczba pokoi w mieszkaniu.
5.  **floor** - piętro, na którym znajduje się oferowany lokal.
6.  **floorCount** - całkowita liczba pięter w budynku.
7.  **buildYear** - rok budowy budynku.
8.  **latitude** - szerokość geograficzna lokalizacji.
9.  **longitude** - długość geograficzna lokalizacji.
10. **centreDistance** - odległość mieszkania od ścisłego centrum miasta (w km).
11. **poiCount** - liczba punktów użyteczności publicznej (Points of Interest) w najbliższej okolicy.
12. **schoolDistance** - odległość do najbliższej szkoły.
13. **clinicDistance** - odległość do najbliższej przychodni/kliniki.
14. **postOfficeDistance** - odległość do najbliższej placówki pocztowej.
15. **kindergartenDistance** - odległość do najbliższego przedszkola.
16. **restaurantDistance** - odległość do najbliższej restauracji.
17. **collegeDistance** - odległość do najbliższej uczelni wyższej.
18. **pharmacyDistance** - odległość do najbliższej apteki.
19. **ownership** - forma własności lokalu (np. własność, spółdzielcze własnościowe).
20. **buildingMaterial** - materiał, z którego wykonany jest budynek (np. cegła, wielka płyta).
21. **condition** - stan techniczny mieszkania.
22. **hasParkingSpace** - informacja, czy do mieszkania przynależy miejsce parkingowe (tak/nie).
23. **hasBalcony** - informacja, czy mieszkanie posiada balkon (tak/nie).
24. **hasElevator** - informacja, czy w budynku znajduje się winda (tak/nie).
25. **hasSecurity** - informacja, czy budynek jest chroniony/monitorowany (tak/nie).
26. **hasStorageRoom** - informacja, czy do mieszkania przynależy komórka lokatorska (tak/nie).
27. **price** - cena całkowita nieruchomości (zmienna celu, którą będziemy przewidywać/analizo

## 2. Data Wrangling, Cleasing

ramach przygotowania zbioru do analizy przeprowadzono dwa kluczowe procesy:

-   **Data Wrangling** – polega na przekształceniu, reorganizacji i mapowaniu surowych danych do formatu, który jest technicznie gotowy do analizy (np. zmiana typów zmiennych).
-   **Data Cleansing** (Czyszczenie danych) – to identyfikacja i eliminacja błędów, niespójności oraz brakujących wartości.

**Cel:** Poprawa jakości danych, co jest fundamentem trafnych decyzji biznesowych.

### 2.1 Komputacja NA

Celem tego etapu jest identyfikacja, wizualizacja oraz uzupełnienie brakujących danych (NA). Braki danych mogą znacząco wpłynąć na jakość modelu predykcyjnego, dlatego kluczowe jest zrozumienie ich struktury – czy występują losowo, czy też wykazują specyficzne wzorce.

#### Mapa braków danych (Overview)

Na początek wykorzystujemy funkcję `vis_miss` z pakietu `naniar`, aby uzyskać ogólny podgląd kompletności zbioru. Wykres przedstawia "mapę" całego arkusza danych, gdzie czarne paski oznaczają brakujące wartości. Pozwala to na szybką ocenę, które zmienne są najbardziej problematyczne.

```{r echo=FALSE, message=FALSE, warning=FALSE, fig.width=10, fig.height=6}
library(dplyr)
library(mice)
library(naniar)
library(ggplot2)

dane <- read.csv("apartments_rent_pl_2024_06.csv")

vis_miss(dane, warn_large_data = FALSE) +
  labs(title = "Mapa braków danych w zbiorze (Missingness Map)") +
  theme(axis.text.x = element_text(angle = 90))
```

#### Analiza wzorców (Pattern Analysis)
Aby dokładniej zrozumieć strukturę braków, stosujemy funkcję md.pattern. Wykres ten (w kolorach niebieskim i różowym) pokazuje kombinacje braków.

Kolor niebieski: Dane dostępne.

Kolor różowy: Brak danych. Wizualizacja ta pomaga odpowiedzieć na pytanie: "Czy jeśli brakuje nam informacji o roku budowy, to zazwyczaj brakuje też informacji o piętrze?".

```{r echo=FALSE, message=FALSE, warning=FALSE, fig.width=8, fig.height=6}
# invisible() ukrywa tabelę liczbową, zostawiając sam wykres
invisible(md.pattern(dane, rotate.names = TRUE))
```

Uzupełnieniem powyższej analizy jest wykres gg_miss_upset (tzw. Upset Plot). Pionowe słupki pokazują liczebność poszczególnych kombinacji brakujących zmiennych. Pozwala to szybko zidentyfikować najczęstsze "scenariusze" braków danych.

```{r echo=FALSE, fig.height=6, fig.width=10, message=FALSE, warning=FALSE}
gg_miss_upset(dane, nsets = 10, nintersects = 10)
```

#### Zależność braków od zmiennych kategorycznych
Poniższa mapa ciepła (gg_miss_fct) sprawdza, czy występowanie braków danych w zmiennych numerycznych jest skorelowane z obecnością windy w budynku (hasElevator). Pozwala to wykryć systematyczne błędy w zbieraniu danych (np. czy dla budynków bez windy częściej brakuje pewnych informacji).

```{r echo=FALSE, message=FALSE, warning=FALSE, fig.width=10, fig.height=6}
gg_miss_fct(x = dane, fct = hasElevator) + 
  labs(title = "Rozkład braków danych w podziale na dostępność windy")
```

#### Imputacja danych (MICE)
Usuwanie rekordów z brakami danych (tzw. listwise deletion) wiązałoby się ze znaczną utratą informacji, co mogłoby obciążyć model. Zamiast tego zastosowano metodę wielokrotnej imputacji MICE (Multivariate Imputation by Chained Equations) z algorytmem PMM (Predictive Mean Matching).

Metoda ta uzupełnia braki, "pożyczając" wartości od innych, statystycznie podobnych mieszkań w zbiorze, co pozwala zachować naturalny rozkład danych i wariancję.

```{r echo=FALSE, message=FALSE, warning=FALSE, fig.width=10, fig.height=6}
# Przygotowanie do imputacji (usunięcie kolumny ID, która nie wnosi wartości analitycznej)
dane_do_imputacji <- dane %>% select(-id)

# Imputacja algorytmem PMM (printFlag=FALSE ukrywa logi techniczne procesu)
imputed <- mice(dane_do_imputacji, m = 5, method = 'pmm', seed = 123, printFlag = FALSE)
completed_data <- complete(imputed, 1)
```
#### Weryfikacja po imputacji
Poniższy wykres potwierdza skuteczność procesu imputacji. Brak widocznych pasków dla zmiennych (lub wartości 0%) oznacza, że zbiór danych jest teraz kompletny i technicznie gotowy do dalszego modelowania.

```{r echo=FALSE, message=FALSE, warning=FALSE, fig.width=10, fig.height=6}
gg_miss_var(completed_data, show_pct = TRUE) + 
  labs(title = "Weryfikacja: Procent braków danych po imputacji")
```

### 2.2 Struktura danych i statystyki opisowe

W tym kroku przyglądamy się technicznej stronie zbioru danych. Sprawdzamy typy zmiennych (czy liczby są liczbami, a tekst tekstem), rozkład wartości oraz różnorodność kategorii. Pozwala to wyłapać anomalie, takie jak np. literówki w nazwach miast czy nierealistyczne ceny.

#####  Wizualizacja typów danych (Data Types)

Poniższy wykres (`vis_dat`) to "zdjęcie rentgenowskie" naszego zbioru danych. Każda kolumna to zmienna, a kolory oznaczają typ danych (np. liczby całkowite, napisy).
* Pozwala szybko ocenić, czy R poprawnie zinterpretował dane (np. czy cena nie jest traktowana jako tekst).
* Szare pola (jeśli są) wskazują miejsca brakujące (NA).

```{r echo=FALSE, message=FALSE, warning=FALSE, fig.width=10, fig.height=6}
library(visdat)
library(dplyr)

# Upewniamy się, że pracujemy na świeżych danych (lub tych po imputacji - zależy od Ciebie)
# Tutaj wczytuję oryginał dla demonstracji struktury
dane_temp <- read.csv("apartments_rent_pl_2024_06.csv") %>% select(-id)

vis_dat(dane_temp) +
  labs(title = "Struktura typów danych (vis_dat)")
```

##### Podstawowe statystyki (Summary)
Funkcja summary() generuje statystyczny opis każdej zmiennej.

Dla zmiennych liczbowych (np. price, squareMeters) widzimy: średnią (Mean), medianę oraz wartości skrajne (Min, Max).

Pozwala to szybko zauważyć błędy, np. mieszkanie o powierzchni 1 m² lub cenie ujemnej.

```{r echo=FALSE, message=FALSE, warning=FALSE}
# Wyświetlamy podsumowanie
summary(dane_temp)
```
##### Analiza unikalnych wartości
Poniższa tabela pokazuje, ile unikalnych wartości ma każda zmienna.

Zmienne o małej liczbie unikalnych wartości (np. 2-5) to zazwyczaj zmienne kategoryczne (np. hasElevator, condition).

Zmienne o dużej liczbie wartości to zmienne ciągłe (np. price, latitude).
```{r echo=FALSE, message=FALSE, warning=FALSE}
# Tworzymy ramkę danych z liczbą unikalnych wartości dla każdej kolumny
unikalne_wartosci <- data.frame(
  Zmienna = names(dane_temp),
  Liczba_Unikalnych = sapply(dane_temp, function(x) length(unique(x)))
)

# Sortujemy dla czytelności (od najmniejszej liczby kategorii)
unikalne_wartosci <- unikalne_wartosci[order(unikalne_wartosci$Liczba_Unikalnych), ]

# Wyświetlamy wynik (używamy knitr::kable dla ładniejszej tabeli w HTML)
knitr::kable(unikalne_wartosci, row.names = FALSE, caption = "Liczba unikalnych wartości w kolumnach")
```
##### Proporcje dla kluczowych kategorii
Poniżej sprawdzamy rozkład (liczność) dla najważniejszych zmiennych opisowych. Pozwala to ocenić, czy mamy do czynienia z niezbalansowanymi danymi (np. czy 99% mieszkań jest w stanie "Premium").

##### Materiał budowy (buildingMaterial):
```{r echo=FALSE, message=FALSE, warning=FALSE, fig.width=8, fig.height=6}
table(dane_temp$buildingMaterial)
```

##### Stan mieszkania (condition):
```{r echo=FALSE, message=FALSE, warning=FALSE, fig.width=8, fig.height=6}
table(dane_temp$condition)
```

##### Dostępność windy (hasElevator):
```{r echo=FALSE, message=FALSE, warning=FALSE, fig.width=8, fig.height=6}
# Zamiana wartości logicznych/tekstowych na czytelną tabelę
table(dane_temp$hasElevator)
```


### 2.4 Data Cleansing (Transformacja zmiennych)

Na tym etapie przygotowujemy dane do modelowania. Większość algorytmów uczenia maszynowego nie potrafi przetwarzać surowego tekstu (np. "winda: tak", "materiał: cegła"). Konieczna jest konwersja zmiennych kategorycznych (jakościowych) na format numeryczny.

Poniższe wykresy obrazują ten proces transformacji.

#### Wizualizacja przed i po transformacji

Pierwszy wykres pokazuje surowy zbiór danych. Kolor **czerwony/różowy** oznacza zmienne tekstowe (`character`), które są niezrozumiałe dla modelu matematycznego.
Drugi wykres pokazuje ten sam zbiór po zastosowaniu funkcji czyszczącej. Wszystkie zmienne zostały przekonwertowane na **typy numeryczne (zielony/niebieski)**, co oznacza pełną gotowość do analizy.

```{r echo=FALSE, fig.height=14, fig.width=12, message=FALSE, warning=FALSE}
library(visdat)
library(dplyr)
library(gridExtra)
library(ggplot2) # Potrzebne do funkcji margin()

# 1. Wczytujemy dane
dane_raw <- read.csv("apartments_rent_pl_2024_06.csv") %>% select(-id)

# 2. Definiujemy wspólny motyw (żeby nie pisać tego dwa razy)
# margin(t, r, b, l) -> top, right, bottom, left
moj_styl <- theme(
  plot.title = element_text(size = 14, face = "bold", margin = margin(b = 20)), # Odstęp pod tytułem
  plot.margin = margin(20, 10, 20, 10), # Marginesy dookoła całego wykresu
  axis.text.x = element_text(angle = 90, size = 8, vjust = 0.5) # Pionowe napisy
)

# 3. WYKRES 1: PRZED
p1 <- vis_dat(dane_raw) +
  labs(title = "1. Dane surowe (Tekst = Czerwony)") +
  moj_styl

# 4. TRANSFORMACJA
dane_cleaned <- dane_raw %>%
  mutate(
    across(where(is.logical), as.integer), 
    across(where(is.character), ~as.numeric(as.factor(.)))
  )

# 5. WYKRES 2: PO
p2 <- vis_dat(dane_cleaned) +
  labs(title = "2. Dane po transformacji (Liczby = Zielony/Niebieski)") +
  moj_styl

# 6. Wyświetlenie z większymi odstępami
grid.arrange(p1, p2, ncol = 1)
```


### 2.5 Segmentacja ofert (Klastrowanie)

W celu głębszego zrozumienia rynku, zamiast analizować każde mieszkanie z osobna, pogrupujemy je w podobne do siebie segmenty. Wykorzystamy algorytm **K-Means**.

#### Wybór optymalnej liczby grup

Metoda "Silhouette" wskazała, że najbardziej optymalnym podziałem zbioru jest podział na **2 klastry** (najwyższa wartość na wykresie). Oznacza to, że rynek dzieli się naturalnie na dwie wyraźne kategorie ofert.

```{r echo=FALSE, message=FALSE, warning=FALSE, fig.width=10, fig.height=5}
library(cluster)
library(factoextra)
library(dplyr)

# 1. Wybór zmiennych (bez id i kategorii tekstowych)
dane_do_klastrowania <- dane_cleaned %>%
  select(price, squareMeters, rooms, centreDistance, buildYear) %>%
  na.omit()

# 2. Skalowanie
dane_scaled <- scale(dane_do_klastrowania)

# 3. Wykres (Ten, który już masz - potwierdza k=2)
fviz_nbclust(dane_scaled, kmeans, method = "silhouette") +
  labs(title = "Optymalna liczba klastrów (Metoda Silhouette)")


```

####  Wizualizacja segmentów (Cluster Plot)
Dokonujemy podziału rynku na 2 główne segmenty. Poniższy wykres pokazuje, jak te dwie grupy są odseparowane od siebie w przestrzeni cech.


```{r echo=FALSE, message=FALSE, warning=FALSE, fig.width=10, fig.height=6}
set.seed(123)

# UWAGA: Tutaj zmieniliśmy centers = 2 (zgodnie z Twoim wykresem)
km_res <- kmeans(dane_scaled, centers = 2, nstart = 25)

# Wizualizacja
fviz_cluster(km_res, data = dane_scaled,
             palette = "jco",
             ggtheme = theme_minimal(),
             geom = "point",
             ellipse.type = "convex",
             main = "Podział rynku na 2 segmenty")
```

#### Charakterystyka grup (Profilowanie)
Aby zrozumieć, czym różnią się te dwie grupy ( "Mieszkanie tanie" vs "drogie"), spójrzmy na średnie wartości.

```{r echo=FALSE, message=FALSE, warning=FALSE}
# Łączymy wyniki z danymi
dane_z_klastrami <- dane_do_klastrowania %>%
  mutate(Cluster = as.factor(km_res$cluster))

# Liczymy średnie
statystyki <- dane_z_klastrami %>%
  group_by(Cluster) %>%
  summarise(
    Liczba_Ofert = n(),
    Cena_Srednia = round(mean(price), 0),
    Metraz_Sredni = round(mean(squareMeters), 1),
    Pokoje_Srednie = round(mean(rooms), 1),
    Odleglosc_Centrum = round(mean(centreDistance), 2),
    Rok_Budowy = round(mean(buildYear), 0)
  )

knitr::kable(statystyki, caption = "Porównanie parametrów dla 2 segmentów")
```

**Wnioski z segmentacji rynku:**

Algorytm K-Means wyraźnie podzielił rynek na dwie odrębne kategorie, co ma kluczowe znaczenie dla strategii biznesowej i wyceny:

1.  **Segment 1: "Premium / Duży Metraż" (Klaster 1)**
    * Stanowi mniejszą część rynku (ok. 18% ofert).
    * Charakteryzuje się **dużą powierzchnią** (średnio 93 m²) i **liczbą pokoi** (blisko 4).
    * Są to nieruchomości znacznie droższe (średnia cena pow. 7500 jednostek walutowych), celujące w klienta zamożnego lub duże rodziny.
    * Co ciekawe, średni rok budowy (1992) jest niższy niż w drugim segmencie, co może sugerować, że do tej grupy trafiają też starsze, przestronne mieszkania w kamienicach lub starsze budownictwo wielorodzinne.

2.  **Segment 2: "Standard / Inwestycyjny" (Klaster 2)**
    * Dominuje na rynku (ponad 80% ofert).
    * To typowe mieszkania dwupokojowe o powierzchni ok. 46 m².
    * Średnia cena (ok. 3000) jest ponad dwukrotnie niższa niż w segmencie premium.
    * Są to mieszkania nowsze (średni rok 2000), co idealnie wpisuje się w profil popularnych mieszkań deweloperskich lub lokali pod wynajem ("kawalerki" i "dwójki").

## 3. Wizualizacja danych

### 3.1 Wykresy pudełkowe

Wykresy pudełkowe wykorzstane zostały do  graficznego przedstawienia analizy kluczowych czynników wpływających na zróżnicowanie stawek na rynku nieruchomości. Poprzez zestawienie danych w formie czytelnych wykresów, zidentyfikowane zostały zależności między ceną a standardem, lokalizacją oraz parametrami technicznymi lokali. Uzyskamy dzięki nim lepsze zrozumienie struktury rynku i wskazanie segmentów generujących najwyższe koszty najmu.

```{r echo=FALSE, message=FALSE, warning=FALSE}
### 3.1 Analiza zróżnicowania cen - Wykresy Pudełkowe

# Upewniamy się, że biblioteki są załadowane
library(ggplot2)
library(dplyr)
library(patchwork)

# 1. Obliczamy cenę za m2, jeśli jeszcze jej nie ma
plot_data <- completed_data %>%
  mutate(price_per_m2 = price / squareMeters)

# 2. Wykres A: Cena za m2 a Rodzaj Zabudowy
# Używamy as.factor(), bo po kroku 2.4 'type' może być liczbą (1, 2, 3...)
p_type <- ggplot(plot_data, aes(x = reorder(as.factor(type), price_per_m2, FUN = median), 
                                y = price_per_m2, fill = as.factor(type))) +
  geom_boxplot(alpha = 0.7, outlier.colour = "red", outlier.shape = 1) +
  coord_flip() +
  scale_fill_viridis_d(option = "viridis") + # Bezpieczna paleta dla numerów
  theme_minimal() +
  labs(title = "Cena za m2 a rodzaj budynku (kategorie)",
       x = "Kod typu budynku",
       y = "Cena za metr (PLN)") +
  theme(legend.position = "none")
```

```{r echo=FALSE, message=FALSE, warning=FALSE}
# 3. Wykres B: Cena całkowita a liczba pokoi
p_rooms <- ggplot(plot_data, aes(x = as.factor(rooms), y = price, fill = as.factor(rooms))) +
  geom_boxplot(alpha = 0.7) +
  scale_fill_viridis_d(option = "magma") +
  theme_minimal() +
  labs(title = "Całkowity koszt najmu a liczba pokoi",
       x = "Liczba pokoi",
       y = "Cena całkowita (PLN)") +
  theme(legend.position = "none")
```

```{r echo=FALSE, message=FALSE, warning=FALSE}
# 4. Wykres C: Cena za m2 a Stan Mieszkania (Condition)
p_cond <- ggplot(plot_data, aes(x = as.factor(condition), y = price_per_m2, fill = as.factor(condition))) +
  geom_boxplot(alpha = 0.7) +
  scale_fill_brewer(palette = "Pastel1") +
  theme_minimal() +
  labs(title = "Cena za m2 a stan techniczny",
       x = "Kod stanu",
       y = "Cena za metr (PLN)") +
  theme(legend.position = "none")

# Łączenie wykresów (wymaga biblioteki patchwork)
(p_type | p_cond) / p_rooms
```

**Interpretacja wykresów**

Analiza wykresów pudełkowych pokazuje, że rodzaj zabudowy istotnie różnicuje ceny metra kwadratowego – apartamentowce są najdroższym segmentem, podczas gdy kamienice charakteryzują się największą liczbą ofert luksusowych, znacznie wykraczających poza średnią rynkową. Całkowity koszt najmu rośnie wraz z liczbą pokoi, jednak przy większych metrażach obserwujemy znacznie większą rozpiętość cenową i mniejszą przewidywalność kosztów niż w przypadku małych mieszkań. Kluczowym czynnikiem cenotwórczym pozostaje stan techniczny, który tworzy wyraźną strukturę wzrostową, choć atrakcyjna lokalizacja potrafi czasem zrównać cenę lokali o niższym standardzie z mieszkaniami typu premium.

### 3.2 Wykresy słupkowe

Wykresy słupkowe posłużyły do graficznej analizy ilościowej strukturze ofert oraz zestawieniu średnich wartości cenowych w kluczowych kategoriach. Umożliwi to precyzyjne wskazanie, typów nieruchomości dominujących w bazie danych oraz jak rozkładu kosztów najmu w zależności od wielkości mieszkania.

```{r echo=FALSE, message=FALSE, warning=FALSE}
library(ggplot2)
library(dplyr)
library(patchwork)

# 1. Przygotowanie danych - zabezpieczamy typy numeryczne
df_bar1 <- completed_data %>%
  group_by(rooms) %>%
  summarise(count = n())

df_bar2 <- completed_data %>%
  group_by(type) %>%
  summarise(mean_val = mean(as.numeric(price) / as.numeric(squareMeters), na.rm = TRUE))

# 2. Wykres A: Struktura ofert
p_count <- ggplot(df_bar1, aes(x = as.factor(rooms), y = count, fill = as.factor(rooms))) +
  geom_col(alpha = 0.8) +
  geom_text(aes(label = count), vjust = -0.5, size = 3) +
  scale_fill_viridis_d(option = "mako") +
  theme_minimal() +
  labs(title = "Liczba ofert wg pokoi", x = "Pokoje", y = "Liczba") +
  theme(legend.position = "none")

# 3. Wykres B: Średnia cena za metr
p_mean <- ggplot(df_bar2, aes(x = reorder(as.factor(type), mean_val), y = mean_val, fill = as.factor(type))) +
  geom_col(alpha = 0.8) +
  coord_flip() +
  scale_fill_brewer(palette = "Blues") +
  theme_minimal() +
  labs(title = "Średnia cena za m2", x = "Typ budynku (kod)", y = "PLN/m2") +
  theme(legend.position = "none")

# Łączenie wykresów - jeśli tu jest błąd, wpisz install.packages("patchwork")
p_count + p_mean
```
**Interpretacja wykresów**

Analiza struktury ogłoszeń wykazuje wyraźną dominację mieszkań dwu- i trzypokojowych, co sugeruje, że rynek jest zorientowany głównie na segment popularny i potrzeby rodzin. Zestawienie średnich cen potwierdza, że typ zabudowy jest silnym predyktorem kosztów – nowoczesne apartamentowce generują najwyższe stawki za metr kwadratowy, podczas gdy duży wolumen ofert w blokach mieszkalnych utrzymuje ceny na bardziej stabilnym, niższym poziomie. Wyraźne różnice między kategoriami wskazują, że standard budynku jest dla najemców kluczowym czynnikiem przy akceptacji wyższych stawek czynszu.

## 4. Analiza opisowa

### 4.1 Statystyki opisowe

Statystyki opisowe stanowią fundament analizy, pozwalając na liczbowe podsumowanie tendencji centralnej oraz rozproszenia kluczowych cech rynkowych. Dzięki nim możliwe jest precyzyjne określenie profilu typowej oferty oraz zidentyfikowanie skali zróżnicowania cenowego w badanym zbiorze danych.

```{r}
library(dplyr)
library(tidyr)
library(knitr)

# 1. Obliczamy statystyki w sposób bezpieczny
statystyki_tabela <- completed_data %>%
  # Wybieramy tylko te kolumny, które nas interesują
  select(price, squareMeters, rooms, centreDistance) %>%
  # Przekształcamy do formatu długiego, aby łatwo policzyć wszystko na raz
  pivot_longer(everything(), names_to = "Zmienna", values_to = "Wartość") %>%
  group_by(Zmienna) %>%
  summarise(
    Min = min(Wartość, na.rm = TRUE),
    Mediana = median(Wartość, na.rm = TRUE),
    Średnia = mean(Wartość, na.rm = TRUE),
    Max = max(Wartość, na.rm = TRUE),
    `Odch. std.` = sd(Wartość, na.rm = TRUE)
  ) %>%
  # Zaokrąglamy wyniki dla estetyki
  mutate(across(where(is.numeric), ~round(., 2)))

# 2. Wyświetlenie tabeli
kable(statystyki_tabela, caption = "Tabela: Podsumowanie statystyczne kluczowych parametrów")
```

**Interpretacja statystyk opisowych**

Zestawienie liczbowe ujawnia istotne zróżnicowanie stawek najmu, gdzie wyraźna różnica między średnią a medianą cen sygnalizuje obecność ofert luksusowych zawyżających ogólny wynik. Wysokie odchylenie standardowe w relacji do ceny sugeruje, że rynek nie jest jednolity, a na ostateczny koszt silnie wpływają cechy specyficzne lokali. Przeciętny metraż i odległość od centrum wskazują na dominację standardowych mieszkań miejskich, przy czym szeroki zakres od wartości minimalnych do maksymalnych potwierdza dużą rozpiętość standardu dostępnych nieruchomości.

### 4.2 Korelacja

Analiza korelacji pozwala zrozumieć, które cechy nieruchomości mają najsilniejszy związek z jej ceną oraz jak poszczególne parametry wpływają na siebie nawzajem. Wykorzystanie macierzy korelacji ułatwia identyfikację kluczowych czynników cenotwórczych, co jest niezbędne do budowy rzetelnego modelu wyceny.

```{r}
library(corrplot)
library(dplyr)

# 1. Wybieramy tylko zmienne numeryczne do analizy
dane_kor <- completed_data %>%
  select(price, squareMeters, rooms, centreDistance, buildYear, poiCount) %>%
  # Zmieniamy nazwy na polskie dla lepszej czytelności wykresu
  rename(Cena = price, Metraż = squareMeters, Pokoje = rooms, 
         `Dystans Centrum` = centreDistance, `Rok Budowy` = buildYear, `Liczba POI` = poiCount)

# 2. Obliczamy macierz korelacji
M <- cor(dane_kor, use = "complete.obs")

# 3. Rysujemy macierz
corrplot(M, method = "color", type = "upper", 
         addCoef.col = "black", 
         tl.col = "black", tl.srt = 45,
         diag = FALSE,
         title = "\n\nMacierz korelacji czynników rynkowych",
         mar = c(0,0,2,0))
```
**Interpretacja współczynników korelacji**

Analiza współczynników korelacji potwierdza, że powierzchnia mieszkania oraz liczba pokoi są najsilniejszymi stymulantami ceny całkowitej, wykazując silny związek dodatni. Z kolei odległość od centrum miasta wykazuje wyraźną korelację ujemną, co oznacza, że wraz ze wzrostem dystansu od serca miasta ceny najmu tendencyjnie spadają. Pozostałe zmienne, takie jak rok budowy czy liczba punktów użyteczności publicznej, mają mniejszy, ale zauważalny wpływ, co sugeruje, że rynek wycenia nieruchomości wielokryterialnie, biorąc pod uwagę zarówno parametry techniczne, jak i lokalizacyjne.

