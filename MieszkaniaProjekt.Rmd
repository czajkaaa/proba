---
title: "Mieszko"
output: github_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## GitHub Documents

This is an R Markdown format used for publishing markdown documents to GitHub. When you click the **Knit** button all R code chunks are run and a markdown file (.md) suitable for publishing to GitHub is generated.

## Including Code

You can include R code in the document as follows:



## Including Plots
```{r}
library(qwraps2)
library(arsenal)
library(e1071)
library(haven)
library(papeR)
library(dplyr)
library(tidyverse)
library(ggplot2)
library(kableExtra)
library(summarytools)
library(classInt)
library(pastecs)
library(desctable)
library(frequency)
library(corrplot)
library(ggpubr)
```

You can also embed plots, for example:
#NASZE KODY
```{r pressure, echo=FALSE}
dane <- apartments_rent_pl_2024_06

library(mice, warn.conflicts = FALSE)
```




```{r}
md.pattern(dane)

library(dplyr)
dane <- dane %>% select(-id)

imputed <- mice(dane, m = 5, method = 'pmm', seed = 123)
completed_data <- complete(imputed, 1)
View(completed_data)

md.pattern(completed_data)


```


```{r}
#Stripplot for imputed data
stripplot(imputed, pch = 20, cex = 1.2)

```

#ggmice 

```{r}
install.packages("naniar")
library(naniar)
gg_miss_fct(x = completed_data, fct = city)
```


```{r}
# Upewnij się, że masz załadowany pakiet dplyr
library(dplyr)

# Usuwa duplikaty
completed_data_unique <- completed_data %>%
  distinct()

# Sprawdzenie, czy duplikaty zostały usunięte
sum(duplicated(completed_data_unique))
# Powinno zwrócić 0
```

```{r}
#wizualizacja danych
install.packages("ggplot2")
library(ggplot2)
ggplot(completed_data_unique, aes(x = squareMeters, y = price)) +
  geom_point() +
  labs(title = "Zależność między powierzchnią a ceną",
       x = "Powierzchnia (m²)",
       y = "Cena wynajmu (PLN)") +
  theme_minimal()
```
```{r}
library(ggplot2)

# WIZUALIZACJA 1: Wykres punktowy z kolorem dla każdego miasta
ggplot(data = completed_data_unique, 
       aes(x = poiCount, y = price, color = city)) + 
  
  # Punkty (obserwacje)
  geom_point(alpha = 0.6) + 
  
  # Opcjonalnie: Linia regresji dla trendu ogólnego (bez podziału na miasta)
  geom_smooth(method = "lm", se = FALSE, color = "gray20", linetype = "dashed") + 
  
  # Linie trendu dla każdego miasta
  geom_smooth(method = "lm", se = FALSE) +
  
  # Etykiety i tytuł
  labs(title = "Zależność liczby punktów POI i ceny, z podziałem na miasta",
       x = "Liczba punktów POI w pobliżu (poiCount)",
       y = "Cena (price)",
       color = "Miasto") +
  
  # Użycie minimalistycznego motywu
  theme_minimal()
```

```{r}
library(ggplot2)

# WIZUALIZACJA 2: Wykresy panelowe (Faceting)
ggplot(data = completed_data_unique, 
       aes(x = poiCount, y = price)) + 
  
  # Punkty danych (obserwacje)
  geom_point(alpha = 0.6) +
  
  # Dodanie linii trendu (dla każdego panelu z osobna)
  geom_smooth(method = "lm", color = "blue") +
  
  # Podział wykresu na panele według zmiennej 'city'
  facet_wrap(~ city, scales = "free") + 
  
  # Etykiety i tytuł
  labs(title = "Zależność POI i ceny w poszczególnych miastach",
       x = "Liczba punktów POI w pobliżu (poiCount)",
       y = "Cena (price)") +
  
  # Użycie minimalistycznego motywu
  theme_minimal()
```
```{r}
library(dplyr)
library(ggplot2)
install.packages("tidyr")
library(tidyr)


# 1. Agregacja danych (obliczanie średniej ceny dla każdego MIASTA)
dane_avg_city_price <- completed_data_unique %>%
  # Usuń wiersze, gdzie price lub city są NA
  drop_na(city, price) %>% 
  
  # Grupuj według MIASTA
  group_by(city) %>%
  
  # Oblicz średnią cenę dla każdego miasta
  summarise(
    avg_price = mean(price, na.rm = TRUE),
    .groups = 'drop'
  )

library(ggplot2)
# Pakiety dplyr i tidyr są wymagane do utworzenia dane_avg_city_price

# 2. Wizualizacja (wykres słupkowy z gradientem)
ggplot(dane_avg_city_price, 
       aes(x = city, y = avg_price, fill = avg_price)) + # 1. Ustawienie 'fill'
  
  # Rysowanie słupków
  geom_col() +
  
  # 2. Dodanie skali gradientowej
  scale_fill_gradient(low = "lightblue", high = "darkblue", # Możesz wybrać dowolne kolory
                      name = "Średnia cena") + # Tytuł legendy
  
  # Opcjonalnie: Etykiety nad słupkami
  geom_text(aes(label = format(round(avg_price, 0), big.mark = " ")), 
            vjust = -0.5, 
            size = 4, 
            color = "gray30") +
  
  # Etykiety i tytuł
  labs(title = "Średnia cena nieruchomości według miasta (z gradientem)",
       x = "Miasto",
       y = "Średnia cena (PLN)") +
  
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
mieszkania <- completed_data_unique
```
Jak widać nie wszystkie formaty naszych zmiennych są dostosowane. Musimy przygotować odpowiednie formaty naszych zmiennych zgodnie z ich skalą pomiarową i przyszłym zastosowaniem.
```{r wrangling, include=TRUE}
mieszkania$city<-as.factor(mieszkania$city)
mieszkania$type<-as.factor(mieszkania$building)
mieszkania$rooms<-factor(mieszkania$rooms,ordered=TRUE)
attach(mieszkania)
mieszkania$price<-as.numeric(mieszkania$price)

```

W pierwszym etapie naszej analizy pogrupujemy nasze dane w postaci prostej tabeli częstości.

Najpierw przyjrzyjmy się rozkładowi cen mieszkań w naszej próbie i zweryfikujmy poprawność tabelaryczną za pomocą miary TAI:

```{r table, message=FALSE, warning=FALSE, include=FALSE, paged.print=FALSE}
library(frequency)
etykiety<-c("0-2500 PLN", "2500-5000 PLN","5000-7500 PLN","7500-10000 PLN","10000-12500 PLN","12500-15000 PLN","15000-17500 PLN", "17500-20000 PLN")
limits<-cut(mieszkania$price,seq(0,20000,by=2500),labels=etykiety)
tabela1<-freq(limits,type="html")


#zrób histogram obrazujący price podzielony na 10 kategorii
hist(mieszkania$price, breaks=10, main="Histogram cen mieszkań", xlab="Cena (PLN)", col="lightblue", border="black")

```

```{r tai, echo=FALSE}
kbl(tabela1,caption = "Mieszkania - ceny w PLN") %>%
    kable_material(c("striped", "hover"))
tab1<-classIntervals(mieszkania$price,n=10,style="fixed",fixedBreaks=seq(0,20000,by=2500))
#jenks.tests(tab1)
```

```{r histogram, echo=FALSE}
#usuń brakujące wartości z type
type<-mieszkania$type[!is.na(mieszkania$type)]
# Zastosowanie reguły Freedman/Diaconis s.120 ("Algorytm, który automatycznie wybiera szerokość i położenie bloków w oparciu o wielkość próby i rozrzut danych" http://www.mathworks.com/help/toolbox/stats/bqucg6n.html)
hist(price, breaks="FD", col="green", probability = TRUE,
     main="Ceny")
lines(density(price[type=="blockOfFlats"]),col=2)
lines(density(price[type=="apartmentBuilding"]),col=3)
lines(density(price[type=="tenement"]),col=4)
legend("topright", legend=c("blockOfFlats", "apartamentBuilding", "tenement"),
       col=c(2,3,4), lty=1:2, horiz=FALSE, box.lty=0, cex=0.8)

```

```{r histogram2, echo=TRUE}
# Density plot of "price"
#::::::::::::::::::::::::::::::::::::::
density.p <- ggdensity(mieszkania, x = "price", 
                       fill = "district", palette = "jco")+
  stat_overlay_normal_density(color = "red", linetype = "dashed")

# Liczymy statystyki wg typów:
stable <- desc_statby(mieszkania, measure.var = "price",
                      grps = "type")
stable <- stable[, c("type", "length", "mean", "sd")]
# Wykres, szablon "medium orange":
stable.p <- ggtexttable(stable, rows = NULL, 
                        theme = ttheme("mOrange"))
# Podpisujemy wykres:
#::::::::::::::::::::::::::::::::::::::
text <- paste("Ceny mieszkań wg 3 typów ",
              "Losowa próba 200 mieszkań.",
               sep = " ")
text.p <- ggparagraph(text = text, face = "italic", size = 11, color = "black")
# Aranżujemy wykresy na tym samym panelu:
#ggarrange(density.p, stable.p, text.p, 
          #ncol = 1, nrow = 3,
         # heights = c(1, 0.5, 0.3))
```

```{r boxplot2, echo=FALSE}
ggplot(mieszkania, aes(x=type, y=price)) +
    geom_boxplot(alpha=0.7) +
    stat_summary(fun="mean", geom="point", shape=20, size=5, color="red", fill="red") +
 geom_jitter() +
    facet_grid(~rooms) +
    scale_fill_brewer(palette="Set1")

```

```{r facet1, echo=FALSE}
plot1 <- ggplot(mieszkania, aes(price, rooms)) + 
  geom_abline() +
  geom_jitter(width = 0.1, height = 0.1) 
plot1 + facet_wrap(~type)
```

 mean(price)
    median(price)
    sd(price) #standard deviation
    var(price) #variance
    coeff_var<-sd(price)/mean(price) #coefficient of variability %
    coeff_var
    IQR(price)# difference between quartiles =Q3-Q1 
    sx<-IQR(price)/2  #interquartile deviation
    coeff_varx<-sx/median(price) #IQR coefficient of variability %
    coeff_varx
    min(price)
    max(price)
    quantile(price,probs=c(0,0.1,0.25,0.5,0.75,0.95,1),na.rm=TRUE)
    
```{r kable_report, echo=FALSE}
mieszkania_list <- split(mieszkania$price, mieszkania$rooms)
inline_plot <- data.frame(rooms = c(1, 2, 3, 4), boxplot = "", histogram = "", line1 = "", line2 = "", points1 = "")
  inline_plot %>%
  kbl(booktabs = TRUE) %>%
  kable_paper(full_width = FALSE) %>%
  column_spec(2, image = spec_boxplot(mieszkania_list)) %>%
  column_spec(3, image = spec_hist(mieszkania_list)) %>%
  column_spec(4, image = spec_plot(mieszkania_list, same_lim = TRUE)) %>%
  column_spec(5, image = spec_plot(mieszkania_list, same_lim = FALSE)) %>%
  column_spec(6, image = spec_plot(mieszkania_list, type = "p"))

```

```{r kable_report2, echo=FALSE, message=FALSE, warning=FALSE, results='asis'}
library(psych)
raport <-
  list("Cena w PLN" =
       list("Min"= ~ min(price),
            "Max"= ~ max(price),
            "Kwartyl dolny"= ~ quantile(price,0.25),
            "Mediana"= ~ round(median(price),2),
            "Kwartyl górny"= ~ quantile(price,0.75),
            "Średnia"= ~ round(mean(price),2),
            "Odch. std."= ~ round(sd(price),2),
            "IQR"= ~ round(iqr(price),2),
            "Odchylenie ćwiartkowe"=~round(iqr(price)/2,2),
            "Odch. std. w %"=~round((sd(price)/mean(price)),2),
            "Odch. ćwiartkowe w %"=~round((iqr(price)/median(price)),2),
            "Skośność"=~round(skew(price),2),
            "Kurtoza"=~round(kurtosi(price),2)
            ))
tabela<-summary_table(mieszkania, summaries = raport, by = c("rooms"))

knitr::kable(tabela,
  digits = 3,
  align = "lcccc",
  caption="Tabela 1. Mieszkania ceny w PLN wg liczby pokoi.",
  col.names = c("Statystyka","1 pokój", "2 pokoje", "3 pokoje", "4 pokoje")) 

install.packages("ggstatsplot")
library(ggstatsplot)
completed_data %>%
  ggbetweenstats(
    x = squareMeters,
    y = price,
    xlab = "Metraż",
    ylab = "Cena",
    bf.mnessage = FALSE)
```
